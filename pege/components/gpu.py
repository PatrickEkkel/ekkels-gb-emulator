from .mmu import MMU
from .screen import Screen

class Tile:
    def __init__(self):
        self.rows = []

    def add(self, row):
        self.rows.append(row)

class TileRow:

    def __init__(self, fb, sb):
        self.fb = fb
        self.sb = sb
        self.row = []
    def decode(self):
        for x in range(7, -1, -1):
            msb = self.fb >> x & 0x01
            lsb = self.sb >> x & 0x01

            if msb and lsb:
                self.row.append(Screen.DARK_GREEN)
            elif not msb and not lsb:
                self.row.append(Screen.LIGHTEST_GREEN)
            elif msb and not lsb:
                self.row.append(Screen.DARKEST_GREEN)
            elif lsb and not msb:
                self.row.append(Screen.LIGHT_GREEN)


class GPU:

    OAM_SEARCH = 0
    PIXEL_TRANSFER = 1
    VBLANK = 2
    HBLANK = 3

    def __init__(self, mmu, screen, clock):
        self._mmu = mmu
        self._screen = screen
        self._clock = clock
        self.current_mode = GPU.OAM_SEARCH


    def format_hex(self, opcode):
        return ("0x{:x}".format(opcode))

    def _decode_tile_row(self, address, offset):
        tile_row = address + offset

        fb = tile_row
        sb = tile_row + 1

        first_byte = self._mmu.read(fb)
        second_byte = self._mmu.read(sb)

        tr = TileRow(first_byte, second_byte)

        tr.decode()
        return tr

    def _tick(self):
        if self._clock.start_of_cycle():
            pass
        self._clock.tick()

    def step(self):

        if self._clock.lines_drawn >= 144:
            self.current_mode = GPU.VBLANK
            #print(self._clock.lines_drawn)
            #print('VBLANK')
        elif self._clock.lines_drawn > 152 and self._clock.lines_drawn < 155:
            self.current_mode = GPU.OAM_SEARCH
            #print('OAM_SEARCH')
        else:

            if self._clock.line_counter == 20 and self.current_mode == GPU.OAM_SEARCH:
                self.current_mode = GPU.PIXEL_TRANSFER
                #print('PIXEL_TRANSFER')
            elif self._clock.line_counter == 63 and self.current_mode == GPU.PIXEL_TRANSFER:
                self.current_mode = GPU.HBLANK
                #print('HBLANK')
            elif self._clock.line_counter == 114:
                self.current_mode = GPU.OAM_SEARCH
                #print('OAM_SEARCH')
            
        self._tick()

    def create_tile(self, vram_address):
        newTile = Tile()
        for x in range(0,16,2):
            tr = self._decode_tile_row(vram_address, x)
            newTile.add(tr)
        return newTile

    def write_tile(self, vram_address, tile):
        offset = 0
        for i in tile:
            offset_address = vram_address + offset
            self._mmu.write(offset_address, i)
            offset += 1

  
        

    # Test method to test if we get the GPU/Screen implementation right
    def render_nintento_logo(self):
         # loop through VRAM to get tileset info
        start =  MMU.VRAM_START
        current = start
        end = MMU.VRAM_END


        nintendo_tiles = {
            0x8000: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
            0x8010: [0xF0,0x00,0xF0,0x00,0xFC,0x00,0xFC,0x00,0xFC,0x00,0xFC,0x00,0xF3,0x00,0xF3,0x00],
            0x8020: [0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00],
            0x8030: [0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0xF3,0x00,0xF3,0x00],
            0x8040: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xCF,0x00,0xCF,0x00],
            0x8050: [0x00,0x00,0x00,0x00,0x0F,0x00,0x0F,0x00,0x3F,0x00,0x3F,0x00,0x0F,0x00,0x0F,0x00],
            0x8060: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0xC0,0x00,0x0F,0x00,0x0F,0x00],
            0x8070: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0xF0,0x00],
            0x8080: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF3,0x00,0xF3,0x00],
            0x8090: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0xC0,0x00],
            0x80A0: [0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0xFF,0x00,0xFF,0x00],
            0x80B0: [0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC3,0x00,0xC3,0x00],
            0x80C0: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0xFC,0x00],
            0x80D0: [0xF3,0x00,0xF3,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00],
            0x80E0: [0x3C,0x00,0x3C,0x00,0xFC,0x00,0xFC,0x00,0xFC,0x00,0xFC,0x00,0x3C,0x00,0x3C,0x00],
            0x80F0: [0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00],
            0x8100: [0xF3,0x00,0xF3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00],
            0x8110: [0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00],
            0x8120: [0x3C,0x00,0x3C,0x00,0x3F,0x00,0x3F,0x00,0x3C,0x00,0x3C,0x00,0x0F,0x0,0x00,0xF00],
            0x8130: [0x3C,0x00,0x3C,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0xFC,0x00],
            0x8140: [0xFC,0x00,0xFC,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00,0xF0,0x00],
            0x8150: [0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF3,0x00,0xF0,0x00,0xF0,0x00],
            0x8160: [0xC3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00,0xC3,0x00,0xFF,0x00,0xFF,0x00],
            0x8170: [0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xCF,0x00,0xC3,0x00,0xC3,0x00],
            0x8180: [0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0xFC,0x00,0xFC,0x00],
            0x8190: [0x3C,0x00,0x42,0x00,0xB9,0x00,0xA5,0x00,0xB9,0x00,0xA5,0x00,0x42,0x00,0x3C,0x00] 
        }



        # add copyright sign to memory address
        vram_address = 0x8020
        tile = nintendo_tiles[vram_address]

        
        #tile = [0x3C,0x00, 0x42, 0x00, 0xB9, 0x00,0xA5,0x00,0xB9,0x00,0xA5,0x00,0x42,0x00,0x3C,0x00]

        self.write_tile(vram_address, tile)        
        self._screen.render_tile(self.create_tile(vram_address))
